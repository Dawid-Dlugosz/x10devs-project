# Flutter Services Implementation Plan

This document outlines the design for the data source services in the Flutter application, adhering to Clean Architecture principles, and using `fpDart` for error handling and `Freezed` for data models.

## 1. Guiding Principles

-   **Clean Architecture**: Services defined here are part of the `Data Layer`. They encapsulate direct interactions with external data sources (Supabase database, AI service) and are meant to be consumed by repositories.
-   **Error Handling**: All asynchronous methods that perform I/O return a `Future<Either<Failure, T>>`. This ensures robust, exception-free error handling throughout the application.
-   **Immutability**: Data models are defined as immutable classes using the `Freezed` package to ensure predictability and prevent unintended side effects.
-   **Dependency Injection**: Services and repositories are designed as abstract classes (interfaces) with their concrete implementations registered with `get_it` and `injectable`.

## 2. Data Layer Architecture

This project strictly separates the roles of Data Sources (Services) and Repositories to maintain a clean and testable architecture.

-   ### **Services (Data Sources)**
    -   **Responsibility**: Direct, raw communication with a single external data source (e.g., Supabase Auth, a specific database table, or a REST API endpoint).
    -   **Return Types**: Methods should return `Future<Model>`, where `Model` is the Data Transfer Object (DTO) from the external source.
    -   **Error Handling**: On failure, a service **must throw a platform-specific exception** (e.g., `AuthException` from Supabase, `DioException` from Dio). Services **must not** catch their own exceptions or return `Either`.
    -   **Example**: `Future<User> login({required String email})` throws `AuthException`.

-   ### **Repositories**
    -   **Responsibility**: Act as a mediator between the Domain layer and the Data layer. A repository orchestrates data from one or more services (data sources). It is the single source of truth for the application's data.
    -   **Return Types**: All public methods must return a `Future<Either<Failure, T>>`, where `T` is a data model (e.g. `DeckModel`).
    -   **Error Handling**: A repository **must** wrap all service calls in a `try-catch` block. It is responsible for catching platform-specific exceptions from services and mapping them to a specific, application-wide `Failure` type.
    -   **Example**: The repository calls the service's `login` method, catches the `AuthException`, and returns `Left(InvalidCredentialsFailure())`.

## 3. Data Models (DTOs)

These are the core data transfer objects used by the services, derived from the database schema.

### UserModel

**Note**: This model is likely **not needed** in the application. Supabase Auth handles user authentication and provides user data directly through its auth state management. The `userId` is already available as a string from `supabase.auth.currentUser?.id`, and user email can be accessed via `supabase.auth.currentUser?.email`.

**Decision**: Omit this model unless there's a specific need to store additional user profile data beyond what Supabase Auth provides (e.g., custom user preferences, profile pictures, etc.). If such data is needed, it should be stored in a separate `profiles` table and represented by a `UserProfileModel` instead.

For now, we'll rely on Supabase's built-in `User` object from the auth module and reference users by their `String id` throughout the application.

### DeckModel

Represents a flashcard deck.

```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'deck_model.freezed.dart';
part 'deck_model.g.dart';

@freezed
class DeckModel with _$DeckModel {
  @JsonSerializable(fieldRename: FieldRename.snake)
  const factory DeckModel({
    required int id,
    required String userId,
    required String name,
    required int flashcardCount,
    required int createdAt,
  }) = _DeckModel;

  factory DeckModel.fromJson(Map<String, dynamic> json) => _$DeckModelFromJson(json);
}
```

### FlashcardModel

Represents a single flashcard.

```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'flashcard_model.freezed.dart';
part 'flashcard_model.g.dart';

@freezed
class FlashcardModel with _$FlashcardModel {
   @JsonSerializable(fieldRename: FieldRename.snake)
  const factory FlashcardModel({
    required int id,
    required int deckId,
    required String front,
    required String back,
    required bool isAiGenerated,
    required bool wasModifiedByUser,
    required int createdAt,
  }) = _FlashcardModel;

  factory FlashcardModel.fromJson(Map<String, dynamic> json) => _$FlashcardModelFromJson(json);
}
```

### FlashcardCandidateModel

Represents a flashcard generated by AI before it is saved to a deck.

```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'flashcard_candidate_model.freezed.dart';
part 'flashcard_candidate_model.g.dart';

@freezed
class FlashcardCandidateModel with _$FlashcardCandidateModel {
  const factory FlashcardCandidateModel({
    required String front,
    required String back,
  }) = _FlashcardCandidateModel;

  factory FlashcardCandidateModel.fromJson(Map<String, dynamic> json) => _$FlashcardCandidateModelFromJson(json);
}
```

## 4. Core Failure Types

This hierarchy defines the types of errors the application's repositories can return.

```dart
@freezed
sealed class Failure with _$Failure {
  const factory Failure.failure({required String message}) = _Failure;
  const factory Failure.serverFailure({required String message}) = _ServerFailure;
  const factory Failure.authFailure({required String message}) = _AuthFailure;
  const factory Failure.invalidCredentialsFailure({required String message}) = _InvalidCredentialsFailure;
  const factory Failure.emailInUseFailure({required String message}) = _EmailInUseFailure;
  const factory Failure.sessionExpiredFailure({required String message}) = _SessionExpiredFailure;
  const factory Failure.aigenerationFailure({required String message}) = _AIGenerationFailure;
}
```

## 5. Services (Data Sources)

### 5.1. `AuthService`

-   **Description**: Handles all user authentication and session management tasks using Supabase Auth.
-   **Dependencies**: `SupabaseClient`.

#### Interface Definition

```dart
import 'package:fpdart/fpdart.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

abstract class IAuthRemoteDataSource {
  Future<User> register({
    required String email,
    required String password,
  });

  Future<User> login({
    required String email,
    required String password,
  });

  Future<void> logout();

  Future<User?> getCurrentUser();
}
```

#### Methods Breakdown

-   **`register()`**
    -   **Description**: Creates a new user account.
    -   **Parameters**: `email` (String), `password` (String).
    -   **Return Type**: `Future<User>`
    -   **Success Payload**: The newly created and authenticated `User` from Supabase Auth.
    -   **Throws**: `AuthException` on failure (e.g., email in use).

-   **`login()`**
    -   **Description**: Authenticates an existing user.
    -   **Parameters**: `email` (String), `password` (String).
    -   **Return Type**: `Future<User>`
    -   **Success Payload**: The authenticated `User` from Supabase Auth.
    -   **Throws**: `AuthException` on failure (e.g., invalid credentials).

-   **`logout()`**
    -   **Description**: Signs the current user out.
    -   **Parameters**: None.
    -   **Return Type**: `Future<void>`
    -   **Throws**: `AuthException` on failure.

-   **`getCurrentUser()`**
    -   **Description**: Retrieves the currently authenticated user from the session.
    -   **Parameters**: None.
    -   **Return Type**: `User?` (synchronous)
    -   **Success Payload**: A `User` from Supabase Auth if a user is logged in, otherwise `null`.
    -   **Throws**: Does not throw, as it's a synchronous read from the client.

---

### 5.2. `DecksService`

-   **Description**: Manages CRUD operations for user-owned decks in the Supabase database.
-   **Dependencies**: `SupabaseClient`.

#### Interface Definition

```dart
import 'package:fpdart/fpdart.dart';
import 'package:x10devs/models/deck_model.dart';

abstract class IDecksRemoteDataSource {
  Future<List<DeckModel>> getDecks();

  Future<DeckModel> createDeck({required String name});

  Future<DeckModel> updateDeck({
    required int deckId,
    required String newName,
  });

  Future<void> deleteDeck({required int deckId});
}
```

#### Methods Breakdown

-   **`getDecks()`**
    -   **Description**: Fetches all decks owned by the current user.
    -   **Parameters**: None.
    -   **Return Type**: `Future<List<DeckModel>>`
    -   **Success Payload**: A list of `DeckModel` objects.
    -   **Throws**: `PostgrestException` on failure.

-   **`createDeck()`**
    -   **Description**: Creates a new deck for the current user.
    -   **Parameters**: `name` (String).
    -   **Return Type**: `Future<DeckModel>`
    -   **Success Payload**: The newly created `DeckModel` as returned from the database.
    -   **Throws**: `PostgrestException` on failure.

-   **`updateDeck()`**
    -   **Description**: Updates the name of an existing deck.
    -   **Parameters**: `deckId` (int), `newName` (String).
    -   **Return Type**: `Future<DeckModel>`
    -   **Success Payload**: The updated `DeckModel`.
    -   **Throws**: `PostgrestException` on failure.

-   **`deleteDeck()`**
    -   **Description**: Deletes a deck and all its associated flashcards (due to CASCADE).
    -   **Parameters**: `deckId` (int).
    -   **Return Type**: `Future<void>`
    -   **Throws**: `PostgrestException` on failure.

---

### 5.3. `FlashcardsService`

-   **Description**: Manages CRUD operations for flashcards within a specific deck.
-   **Dependencies**: `SupabaseClient`.

#### Interface Definition

```dart
import 'package:fpdart/fpdart.dart';
import 'package:x10devs/models/flashcard_model.dart';

abstract class IFlashcardsRemoteDataSource {
  Future<List<FlashcardModel>> getFlashcardsForDeck({
    required int deckId,
  });

  Future<FlashcardModel> createFlashcard({
    required int deckId,
    required String front,
    required String back,
    bool isAiGenerated = false,
  });

  Future<FlashcardModel> updateFlashcard({
    required int flashcardId,
    required String newFront,
    required String newBack,
    bool wasModifiedByUser = true,
  });

  Future<void> deleteFlashcard({required int flashcardId});
}
```

#### Methods Breakdown

-   **`getFlashcardsForDeck()`**
    -   **Description**: Fetches all flashcards belonging to a specified deck.
    -   **Parameters**: `deckId` (int).
    -   **Return Type**: `Future<List<FlashcardModel>>`
    -   **Success Payload**: A list of `FlashcardModel` objects.
    -   **Throws**: `PostgrestException` on failure.

-   **`createFlashcard()`**
    -   **Description**: Creates a new flashcard in a deck. Used for both manual and AI-accepted cards.
    -   **Parameters**: `deckId` (int), `front` (String), `back` (String), `isAiGenerated` (bool).
    -   **Return Type**: `Future<FlashcardModel>`
    -   **Success Payload**: The newly created `FlashcardModel`.
    -   **Throws**: `PostgrestException` on failure.

-   **`updateFlashcard()`**
    -   **Description**: Updates the content of an existing flashcard.
    -   **Parameters**: `flashcardId` (int), `newFront` (String), `newBack` (String), `wasModifiedByUser` (bool).
    -   **Return Type**: `Future<FlashcardModel>`
    -   **Success Payload**: The updated `FlashcardModel`.
    -   **Throws**: `PostgrestException` on failure.

-   **`deleteFlashcard()`**
    -   **Description**: Deletes a single flashcard from a deck.
    -   **Parameters**: `flashcardId` (int).
    -   **Return Type**: `Future<void>`
    -   **Throws**: `PostgrestException` on failure.

---

### 5.4. `AIGenerationService`

-   **Description**: Communicates with an external AI service (e.g., via OpenRouter) to generate flashcard candidates from user-provided text.
-   **Dependencies**: `Dio` (or another HTTP client).

#### Interface Definition

```dart
import 'package:fpdart/fpdart.dart';
import 'package:x10devs/models/flashcard_candidate_model.dart';

abstract class IAIGenerationRemoteDataSource {
  Future<List<FlashcardCandidateModel>> generateFlashcardsFromText({
    required String text,
  });
}
```

#### Methods Breakdown

-   **`generateFlashcardsFromText()`**
    -   **Description**: Sends a text prompt to the AI service and parses the response into a list of flashcard candidates.
    -   **Parameters**: `text` (String, max 10,000 characters).
    -   **Return Type**: `Future<List<FlashcardCandidateModel>>`
    -   **Success Payload**: A list of `FlashcardCandidateModel` objects.
    -   **Throws**: `DioException` or a custom exception on failure.

