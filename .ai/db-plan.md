# Database Schema for Intelligent Flashcards MVP

This document outlines the complete PostgreSQL database schema designed for the "Intelligent Flashcards" application, based on the Product Requirements Document (PRD) and technical planning sessions.

## 1. Tables

### `public.decks`

This table stores the flashcard decks created by users.

The `public.decks` table contains the following columns:

- **id** (`bigint`):  
  Primary key. Generated by default as identity. Uniquely identifies the deck.

- **user_id** (`uuid`):  
  Not null. References `auth.users(id)` with `ON DELETE CASCADE`. This is a foreign key linking the deck to its owner.

- **name** (`text`):  
  Not null. Deck name. Limited to 100 characters (`CHECK (length(name) <= 100)`).

- **flashcard_count** (`integer`):  
  Not null. Defaults to 0. Denormalized count of flashcards in this deck.

- **created_at** (`timestamptz`):  
  Not null. Defaults to `now()`. Timestamp when the deck was created.

- There is also a unique constraint:  
  `UNIQUE (user_id, name)`  
  This ensures that each user cannot create two decks with the same name.


### `public.flashcards`

This table stores the individual flashcards within each deck.

The `public.flashcards` table contains the following columns:

- **id** (`bigint`):  
  - Primary key. Generated by default as identity.  
  - Uniquely identifies the flashcard.

- **deck_id** (`bigint`):  
  - Not null. References `public.decks(id)` with `ON DELETE CASCADE`.  
  - Foreign key linking to the deck the flashcard belongs to.

- **front** (`text`):  
  - Not null. Limited to 200 characters (`CHECK (length(front) <= 200)`).  
  - The content on the front of the flashcard.

- **back** (`text`):  
  - Not null. Limited to 500 characters (`CHECK (length(back) <= 500)`).  
  - The content on the back of the flashcard.

- **is_ai_generated** (`boolean`):  
  - Not null. Defaults to `false`.  
  - Flag to indicate if the flashcard was generated by AI.

- **was_modified_by_user** (`boolean`):  
  - Not null. Defaults to `false`.  
  - Flag to indicate if an AI-generated flashcard was modified by the user.

- **created_at** (`timestamptz`):  
  - Not null. Defaults to `now()`.  
  - Timestamp of when the flashcard was created.

## 2. Relationships

-   **`auth.users` to `public.decks`**: A one-to-many relationship. A single user can have multiple decks, but each deck belongs to exactly one user. Deleting a user will cascade and delete all of their associated decks and flashcards.
-   **`public.decks` to `public.flashcards`**: A one-to-many relationship. A single deck can contain multiple flashcards, but each flashcard belongs to exactly one deck. Deleting a deck will cascade and delete all of its associated flashcards.

## 3. Indexes

To optimize query performance, the following indexes should be created:

-   `CREATE INDEX ON public.decks (user_id);`
-   `CREATE INDEX ON public.flashcards (deck_id);`

## 4. Row-Level Security (RLS) Policies

RLS must be enabled for both `decks` and `flashcards` tables to ensure data privacy.

```sql
-- Enable RLS on tables
ALTER TABLE public.decks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.flashcards ENABLE ROW LEVEL SECURITY;
```

### Policies for `public.decks`

These policies ensure that users can only interact with their own decks.

```sql
-- Policy for SELECT
CREATE POLICY "Allow users to select their own decks"
ON public.decks FOR SELECT
USING (auth.uid() = user_id);

-- Policy for INSERT
CREATE POLICY "Allow users to insert their own decks"
ON public.decks FOR INSERT
WITH CHECK (auth.uid() = user_id);

-- Policy for UPDATE
CREATE POLICY "Allow users to update their own decks"
ON public.decks FOR UPDATE
USING (auth.uid() = user_id);

-- Policy for DELETE
CREATE POLICY "Allow users to delete their own decks"
ON public.decks FOR DELETE
USING (auth.uid() = user_id);
```

### Policies for `public.flashcards`

These policies ensure that users can only interact with flashcards that belong to decks they own.

```sql
-- Policy for SELECT
CREATE POLICY "Allow users to select flashcards in their own decks"
ON public.flashcards FOR SELECT
USING (
  EXISTS (
    SELECT 1 FROM public.decks
    WHERE decks.id = flashcards.deck_id AND decks.user_id = auth.uid()
  )
);

-- Policy for INSERT
CREATE POLICY "Allow users to insert flashcards into their own decks"
ON public.flashcards FOR INSERT
WITH CHECK (
  EXISTS (
    SELECT 1 FROM public.decks
    WHERE decks.id = flashcards.deck_id AND decks.user_id = auth.uid()
  )
);

-- Policy for UPDATE
CREATE POLICY "Allow users to update flashcards in their own decks"
ON public.flashcards FOR UPDATE
USING (
  EXISTS (
    SELECT 1 FROM public.decks
    WHERE decks.id = flashcards.deck_id AND decks.user_id = auth.uid()
  )
);

-- Policy for DELETE
CREATE POLICY "Allow users to delete flashcards from their own decks"
ON public.flashcards FOR DELETE
USING (
  EXISTS (
    SELECT 1 FROM public.decks
    WHERE decks.id = flashcards.deck_id AND decks.user_id = auth.uid()
  )
);
```

## 5. Additional Design Notes

### Denormalization and Triggers

To optimize performance when fetching the list of decks, the `flashcard_count` column in the `decks` table is denormalized. This count will be maintained by database triggers to avoid expensive real-time calculations.

**Trigger Function:** A function is needed to increment or decrement the `flashcard_count`.

```sql
CREATE OR REPLACE FUNCTION update_flashcard_count()
RETURNS TRIGGER AS $$
BEGIN
  IF (TG_OP = 'INSERT') THEN
    UPDATE public.decks
    SET flashcard_count = flashcard_count + 1
    WHERE id = NEW.deck_id;
  ELSIF (TG_OP = 'DELETE') THEN
    UPDATE public.decks
    SET flashcard_count = flashcard_count - 1
    WHERE id = OLD.deck_id;
  END IF;
  RETURN NULL; -- result is ignored since this is an AFTER trigger
END;
$$ LANGUAGE plpgsql;
```

**Triggers:** Triggers will call the function after a flashcard is inserted or deleted.

```sql
-- Trigger for INSERT
CREATE TRIGGER on_flashcard_insert
AFTER INSERT ON public.flashcards
FOR EACH ROW EXECUTE FUNCTION update_flashcard_count();

-- Trigger for DELETE
CREATE TRIGGER on_flashcard_delete
AFTER DELETE ON public.flashcards
FOR EACH ROW EXECUTE FUNCTION update_flashcard_count();
```
