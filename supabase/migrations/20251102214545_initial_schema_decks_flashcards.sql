-- migration: initial_schema_decks_flashcards
-- description: creates the initial database schema for decks and flashcards, including tables, indexes, rls policies, and triggers.
-- tables_affected: public.decks, public.flashcards

-- step 1: create the 'decks' table
-- this table stores flashcard decks created by users.
create table public.decks (
    id bigint generated by default as identity primary key,
    user_id uuid not null references auth.users(id) on delete cascade,
    name text not null check (length(name) <= 100),
    flashcard_count integer not null default 0,
    created_at timestamptz not null default now(),
    
    -- ensures that each user cannot have multiple decks with the same name.
    constraint user_deck_name_unique unique (user_id, name)
);

-- add comments to the columns of the 'decks' table for clarity.
comment on column public.decks.id is 'primary key. uniquely identifies the deck.';
comment on column public.decks.user_id is 'foreign key linking the deck to its owner in auth.users.';
comment on column public.decks.name is 'name of the deck, limited to 100 characters.';
comment on column public.decks.flashcard_count is 'denormalized count of flashcards in this deck for performance.';
comment on column public.decks.created_at is 'timestamp when the deck was created.';

-- step 2: create the 'flashcards' table
-- this table stores individual flashcards within each deck.
create table public.flashcards (
    id bigint generated by default as identity primary key,
    deck_id bigint not null references public.decks(id) on delete cascade,
    front text not null check (length(front) <= 200),
    back text not null check (length(back) <= 500),
    is_ai_generated boolean not null default false,
    was_modified_by_user boolean not null default false,
    created_at timestamptz not null default now()
);

-- add comments to the columns of the 'flashcards' table.
comment on column public.flashcards.id is 'primary key. uniquely identifies the flashcard.';
comment on column public.flashcards.deck_id is 'foreign key linking the flashcard to its parent deck.';
comment on column public.flashcards.front is 'content on the front of the flashcard, limited to 200 characters.';
comment on column public.flashcards.back is 'content on the back of the flashcard, limited to 500 characters.';
comment on column public.flashcards.is_ai_generated is 'flag to indicate if the flashcard was generated by ai.';
comment on column public.flashcards.was_modified_by_user is 'flag to indicate if an ai-generated flashcard was modified by the user.';
comment on column public.flashcards.created_at is 'timestamp when the flashcard was created.';

-- step 3: create indexes for performance
-- these indexes will speed up queries filtering by user_id on decks and deck_id on flashcards.
create index idx_decks_user_id on public.decks (user_id);
create index idx_flashcards_deck_id on public.flashcards (deck_id);

-- step 4: enable row-level security (rls)
-- rls is enabled on both tables to ensure data privacy and that users can only access their own data.
alter table public.decks enable row level security;
alter table public.flashcards enable row level security;

-- step 5: create rls policies for 'decks' table
-- these policies control access to the decks table for different user roles.

-- policies for authenticated users
-- rationale: authenticated users should be able to fully manage their own decks.
create policy "allow authenticated users to select their own decks"
on public.decks for select
to authenticated
using (auth.uid() = user_id);

create policy "allow authenticated users to insert their own decks"
on public.decks for insert
to authenticated
with check (auth.uid() = user_id);

create policy "allow authenticated users to update their own decks"
on public.decks for update
to authenticated
using (auth.uid() = user_id);

create policy "allow authenticated users to delete their own decks"
on public.decks for delete
to authenticated
using (auth.uid() = user_id);

-- policies for anonymous users
-- rationale: anonymous users should not have any access to the decks table.
create policy "disallow anonymous users to select decks"
on public.decks for select
to anon
using (false);

create policy "disallow anonymous users to insert decks"
on public.decks for insert
to anon
with check (false);

create policy "disallow anonymous users to update decks"
on public.decks for update
to anon
using (false);

create policy "disallow anonymous users to delete decks"
on public.decks for delete
to anon
using (false);

-- step 6: create rls policies for 'flashcards' table
-- these policies control access to the flashcards table for different user roles.

-- policies for authenticated users
-- rationale: authenticated users should be able to manage flashcards only within the decks they own.
create policy "allow authenticated users to select flashcards in their own decks"
on public.flashcards for select
to authenticated
using (exists (select 1 from public.decks where decks.id = flashcards.deck_id and decks.user_id = auth.uid()));

create policy "allow authenticated users to insert flashcards into their own decks"
on public.flashcards for insert
to authenticated
with check (exists (select 1 from public.decks where decks.id = flashcards.deck_id and decks.user_id = auth.uid()));

create policy "allow authenticated users to update flashcards in their own decks"
on public.flashcards for update
to authenticated
using (exists (select 1 from public.decks where decks.id = flashcards.deck_id and decks.user_id = auth.uid()));

create policy "allow authenticated users to delete flashcards from their own decks"
on public.flashcards for delete
to authenticated
using (exists (select 1 from public.decks where decks.id = flashcards.deck_id and decks.user_id = auth.uid()));

-- policies for anonymous users
-- rationale: anonymous users should not have any access to the flashcards table.
create policy "disallow anonymous users to select flashcards"
on public.flashcards for select
to anon
using (false);

create policy "disallow anonymous users to insert flashcards"
on public.flashcards for insert
to anon
with check (false);

create policy "disallow anonymous users to update flashcards"
on public.flashcards for update
to anon
using (false);

create policy "disallow anonymous users to delete flashcards"
on public.flashcards for delete
to anon
using (false);

-- step 7: create trigger function to update flashcard count
-- this function maintains the denormalized 'flashcard_count' in the 'decks' table.
create or replace function public.update_flashcard_count()
returns trigger as $$
begin
  if (tg_op = 'INSERT') then
    update public.decks
    set flashcard_count = flashcard_count + 1
    where id = new.deck_id;
    return new;
  elsif (tg_op = 'DELETE') then
    update public.decks
    set flashcard_count = flashcard_count - 1
    where id = old.deck_id;
    return old;
  end if;
  return null;
end;
$$ language plpgsql;

-- step 8: create triggers to call the function
-- these triggers fire after a flashcard is inserted or deleted.
create trigger on_flashcard_insert
after insert on public.flashcards
for each row execute function public.update_flashcard_count();

create trigger on_flashcard_delete
after delete on public.flashcards
for each row execute function public.update_flashcard_count();
