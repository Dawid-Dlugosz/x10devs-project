---
alwaysApply: true
---


# AI Rules for Flutter + Dart Stack

This document defines the coding and architectural guidelines for a Flutter project using modern tools and best practices.  
All AI-generated code, refactoring, and corrections must comply with these rules to ensure consistency, scalability, and maintainability.

---

## ğŸ§© Tech Stack

**Frontend â€“ Flutter + Dart:**

- **Flutter 3.5** â€” Framework for building beautiful UI and animations quickly.
- **Dart 3.9** â€” Language used for Flutter logic and business code.
- **shadcn/ui 0.0.46** â€” UI component library adapted for Flutter (https://pub.dev/packages/shadcn_flutter).
- **BLoC 9.1.0** â€” State management library, primarily using Cubit (https://pub.dev/packages/bloc).
- **Freezed 3.2.3** â€” Library for creating immutable objects and serialization (https://pub.dev/packages/freezed).
- **Dio 5.9.0** â€” HTTP client for API communication (https://pub.dev/packages/dio).
- **fpDart 1.2.0** â€” Functional programming library for better error and data handling (https://pub.dev/packages/fpdart).
- **getIt 8.3.0** â€” Dependency injection service locator (https://pub.dev/packages/get_it).
- **injectable 2.5.2** â€” Tool for automating dependency injection management with getIt (https://pub.dev/packages/injectable).

---

## ğŸ“ Project Structure

The project should follow the structure below. When introducing changes, this section must be updated accordingly.

```
aplikacja_dart/
â”œâ”€â”€ lib/                             # Main production code
â”‚   â”œâ”€â”€ core/                        # Shared components (errors, utils, DI)
â”‚   â”‚   â”œâ”€â”€ errors/                  # Error definitions (e.g., Failure)
â”‚   â”‚   â””â”€â”€ utils/                   # Utility functions
â”‚   â”‚
â”‚   â””â”€â”€ features/                    # Application features (modules)
â”‚       â””â”€â”€ <feature_name>/          # e.g. login, products
â”‚           â”œâ”€â”€ data/                # DATA layer (repository implementations, data sources)
â”‚           â”‚   â”œâ”€â”€ data_sources/    # API, database, local storage
â”‚           â”‚   â”œâ”€â”€ models/          # Data models for the data layer
â”‚           â”‚   â””â”€â”€ repositories/    # Repository implementations
â”‚           â”‚
â”‚           â”œâ”€â”€ domain/              # DOMAIN layer (business logic, abstractions)
â”‚           â”‚   â”œâ”€â”€ entities/        # Business entities (pure data models)
â”‚           â”‚   â”œâ”€â”€ repositories/    # Abstract repository definitions (interfaces)
â”‚           â”‚
â”‚           â””â”€â”€ presentation/        # PRESENTATION layer (UI and state management)
â”‚               â”œâ”€â”€ bloc/            # State management (BLoC, Cubit, etc.)
â”‚               â”œâ”€â”€ pages/           # Screens and views
â”‚               â””â”€â”€ widgets/         # UI components
```

---

## ğŸ§  General Guidelines for Clean Code

### Principles

- Use **English** for all code, comments, and documentation.
- Always declare **types** for variables, function parameters, and return values.  
  Avoid `dynamic` or `any` unless strictly necessary.
- Do not leave blank lines inside functions.
- Follow **one export per file** convention.
- Maintain small, focused functions â€” less than 20 statements.
- Functions must perform a **single responsibility**.
- Use **early return** to avoid deep nesting.
- Use **guard clauses** for preconditions and invalid states.
- Avoid unnecessary `else` blocks â€” prefer `if-return` pattern.
- Keep each class small and focused â€” under 200 lines and <10 methods.

### Naming Conventions

- **PascalCase** â†’ Classes
- **camelCase** â†’ Variables, functions, methods
- **snake_case** â†’ File and folder names
- **UPPER_CASE** â†’ Constants and environment variables
- Boolean variables should start with a verb (`is`, `has`, `can`).
- Always use **full words**, avoid abbreviations (except for standard ones like API, URL, ctx).

---

## ğŸ—ï¸ Architecture Principles

### Clean Architecture (Feature-First)

Follow Clean Architecture with a **feature-first** organization pattern.

- The project is divided into **Presentation**, **Domain**, and **Data** layers.
- Dependencies always point **inward** (Data â†’ Domain â†’ Presentation).
- Each feature is self-contained and includes its own layers.
- Shared resources are placed under `core/`.
- Prefer **composition over inheritance**.
- Use abstract classes or interfaces to define contracts.
- Maintain strict separation of concerns.

### Recommended Feature Structure

```
lib/
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ errors/
â”‚   â”œâ”€â”€ utils/
â”‚   â””â”€â”€ di/
â””â”€â”€ features/
    â””â”€â”€ example_feature/
        â”œâ”€â”€ data/
        â”‚   â”œâ”€â”€ data_sources/
        â”‚   â”œâ”€â”€ models/
        â”‚   â””â”€â”€ repositories/
        â”œâ”€â”€ domain/
        â”‚   â”œâ”€â”€ entities/
        â”‚   â”œâ”€â”€ repositories/
        â””â”€â”€ presentation/
            â”œâ”€â”€ bloc/
            â”œâ”€â”€ pages/
            â””â”€â”€ widgets/
```

---

## âš™ï¸ State Management (BLoC + Freezed)

- Use **Cubit** for simple states and **Bloc** for event-driven logic.
- All states must be **immutable** and defined with **Freezed**.
- Prefer **union types** (`initial`, `loading`, `success`, `error`) to handle multiple UI states.
- Avoid business logic in widgets â€” handle it inside Blocs or Cubits.
- Use **BlocBuilder** and **BlocListener** with conditions (`buildWhen`, `listenWhen`) for optimization.
- Use **copyWith()** for state transitions.
- Always explicitly handle loading, success, and error states.

---

## ğŸ§© Dependency Injection (getIt + injectable)

- Use **getIt** as a service locator for DI.
- Use **injectable** for automatic dependency generation and registration.
- Register dependencies per feature/module.
- Use:
  - `lazySingleton` for shared services or repositories.
  - `factory` for short-lived instances like blocs or use cases.
  - `singleton` only when global instance is absolutely necessary.
- Keep DI configuration modular â€” one file per feature.

---

## ğŸš¨ Error Handling (fpDart + Failures)

- Use **Either<Failure, T>** for functional error handling.
- Define a base `Failure` class and extend it for specific cases (`ServerFailure`, `CacheFailure`, etc.).
- Map exceptions between layers (Data â†’ Domain â†’ Presentation).
- Avoid throwing exceptions in business logic â€” use result objects.
- Centralize error handling strategy for consistent behavior.
- Use the `fold()` method to handle success/failure outcomes in one place.

Example:

```dart
result.fold(
  (failure) => emit(UserState.error(failure)),
  (user) => emit(UserState.loaded(user)),
);
```

---

## ğŸ§ª Testing Guidelines

- Follow **Arrange â€“ Act â€“ Assert** structure for unit tests.
- Use **Given â€“ When â€“ Then** for integration and feature tests.
- Write unit tests for:
  - Domain logic 
  - Repositories
  - Blocs/Cubits
- Write widget tests for UI components.
- Use `mocktail` for dependency mocking.
- Maintain high test coverage in domain and data layers.
- Keep test names descriptive and consistent (`inputX`, `mockX`, `expectedX`).

---

## ğŸš€ Performance and Optimization

- Use **const constructors** wherever possible to reduce rebuilds.
- Keep widget trees **flat and modular** â€” avoid deep nesting.
- Extract reusable widgets for better structure and readability.
- Use `ListView.builder` for large lists.
- Use `compute()` for heavy operations to avoid blocking the UI thread.
- Implement caching and pagination strategies for performance.
- Optimize network calls with Dio interceptors and retry logic.

---

## ğŸ¨ UI & Theming (shadcn_flutter)

- Use **shadcn_flutter** as the base UI component library.
- Use `ThemeData` to maintain visual consistency across the app.
- Use `AppLocalizations` for translations and localization.
- Maintain high accessibility and contrast standards.
- Build **responsive layouts** for mobile, web, and desktop.
- Use animations only when they add UX value (keep performance in mind).
- Break down large widgets into smaller, composable components.

---

## âœ… Summary

These rules ensure:
- Consistent and maintainable Flutter codebase.
- Scalable architecture based on Clean Architecture principles.
- Reliable and testable business logic.
- High-quality UI implementation using modern Flutter patterns.
- Error-safe functional code with strong typing and DI automation.

Follow these standards for all new code and refactors within this project.

